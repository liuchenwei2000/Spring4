## Spring 消息 ##

使用 RMI、Hessian、Builap、HTTP invoker 和 Web Service 在应用程序之间进行通信的机制都是同步的，客户端应用程序直接与远程服务相交互，并且一直等到远程过程完成后才继续执行。

同步通信有它自己的使用场景。不过对开发者而言，这种通信方式并不是应用程序之间进行交互的唯一方式。异步消息是一个应用程序向另一个应用程序间接发送消息的一种方式，这种方式无需等待对方的响应。

### 异步消息

异步消息也是用于应用程序之间通信的，只是机制有所不同。

像 RMI 这样的 RPC 是同步的，当客户端调用远程方法时，客户端必须等到远程方法完成后，才能继续执行。即使远程方法不向客户端返回任何信息，客户端也要被阻塞直到服务完成。

消息则是异步发送的，客户端不需要等待服务处理消息，甚至不需要等待消息投递完成。客户端发送消息，然后继续执行，这是因为客户端假定服务最终可以收到并处理这条消息。

#### 发送消息

间接性也是异步消息的关键所在。当一个应用向另一个应用发送消息时，两个应用之间没有直接的联系。相反的是，发送方的应用程序会将消息交给一个服务，由服务确保将消息投递给接收方应用程序。

在异步消息中有两个重要的概念：消息代理（message broker）和目的地（destination）。当一个应用发送消息时，会将消息交给一个消息代理。消息代理可以确保消息被投递到指定的目的地，同时解放发送者，使其能够继续进行其他的业务。

尽管不同的消息系统会提供不同的消息路由模式，但是有两种通用的目的地：队列（queue）和主题（topic）。每种类型都与特定的消息模型相关联，分别是点对点模型（队列）和发布/订阅模型（主题）。

**点对点消息模型**

![](http://i1.piimg.com/567571/7b42fe91ae33288d.png)

每一条消息只有一个发送者和一个接收者。当消息代理得到消息时，它将消息放入一个队列中。当接收者请求队列中的下一条消息时，消息会从队列中取出，并投递给接收者。因为消息投递后会从队列中删除，这样就可以保证消息只能投递给一个接收者。

尽管消息队列中的每一条消息只被投递给一个接收者，但并不意味着只能使用一个接收者从队列中获取消息。事实上，通常可以使用几个接收者来处理队列中的消息。不过，每个接收者都只会处理自己所接收到的消息。

消息队列对消息发送者和接收者进行了解耦。如果有多个接收者监听队列，也无法知道某条特定的消息会由哪一个接收者处理。这种不确定性实际上有很多好处，因为只需要简单地为队列添加新的接收者就能提高应用的消息处理能力。

**发布/订阅消息模型**

![](http://i1.piimg.com/567571/c466cebf0e0f050a.png)

消息会发送给一个主题，与队列类似，多个接收者都可以监听一个主题。但是与队列不同的是，消息不再是只投递给一个接收者，而是主题的所有订阅者都会接收到此消息的副本。

### 同步消息与异步消息的对比

同步消息的限制：

* 同步通信意味着等待
* 客户端通过服务接口与远程服务耦合（API 变化会影响到客户端）
* 客户端与远程服务的地址耦合（网络地址变化会影响到客户端）
* 客户端与远程服务的可用性耦合（服务不可用则客户端不可用）

异步消息能够突破这些限制，如下：

* 无需等待，客户端的性能能够极大地提高。
* 面向消息和解耦，发送异步消息是以数据为中心的。这意味着客户端并没有与特定的方法签名绑定，任何可以处理数据的队列或主题订阅者都可以处理由客户端发送的消息，而客户端不必了解远程服务的人和规范。
* 位置独立。消息客户端不必知道谁会处理它们的消息，或者服务的位置在哪里。客户端只需要了解需要通过哪个队列或主题来发送消息，服务端只需要了解从哪个队列或主题中获取消息即可。消息客户端根本不需要关注服务来自哪里。
* 确保投递。当发送异步消息时，客户端完全可以相信消息会被投递。即使在消息发送时，服务无法使用，消息也会被存储起来，直到服务重新可以使用为止。

